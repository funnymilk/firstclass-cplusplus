/*

Задать целочисленный массив, состоящий из элементов 0 и 1. Например: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ]. Написать функцию, заменяющую в принятом массиве 0 на 1, 1 на 0 (** без применения if-else, switch, () ? :);

Задать пустой целочисленный массив размером 8. Написать функцию, которая с помощью цикла заполнит его значениями 1 4 7 10 13 16 19 22;

* Написать функцию, в которую передается не пустой одномерный целочисленный массив, функция должна вернуть истину если в массиве есть место, в котором сумма левой и правой части массива равны. Примеры: checkBalance([1, 1, 1, || 2, 1]) → true, checkBalance ([2, 1, 1, 2, 1]) → false, checkBalance ([10, || 1, 2, 3, 4]) → true. Абстрактная граница показана символами ||, эти символы в массив не входят.

* Написать функцию, которой на вход подаётся одномерный массив и число n (может быть положительным, или отрицательным), при этом функция должна циклически сместить все элементы массива на n позиций.

** Написать функцию из первого задания так, чтобы она работала с аргументом переменной длины.

** Написать все функции в отдельных файлах в одном пространстве имён, вызвать их на исполнение в основном файле программы используя указатели на функции.

*/

#include <iostream>

namespace home {
void carr(int a[]);
void incl(int a[]);
bool checkBalance(int a[]);
void shift(int a[], int b = 2);
void ar(int size, ...);
}

int main(){
//задание 1*
	void (* ch)(int a[]);
	ch = home::carr;
	int b[] = {1, 1, 0, 0, 1, 0, 1, 1, 0, 0};	
	//carr(b);
	(*ch)(b);
	ch(b);
//заданиче 2 
	void (*inpoint)(int a[]);
	inpoint = home::incl;
	int x[8];	
	inpoint(x);
	//incl(x);	
	
//задание 3
	bool (* trf)(int a[]);
	trf = home::checkBalance;
	int n[] = {1, 1, 1, 2, 1};
	int n2[] = {10, 1, 1, 2, 1};
	std::cout << std::boolalpha << trf(n) << std::endl;
	//std::cout << std::boolalpha << checkBalance(n) << std::endl;
	
//задание 4
	void (* sdvig)(int a[], int b);
	sdvig = home::shift;
	int o[] = {1, 2, 3, 4, 5};
	sdvig(o, -2);
	//shift(o);
//задание 5 
	void (*z5)(int k, ...);
	z5 = home::ar;
	z5(10, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0);
}


